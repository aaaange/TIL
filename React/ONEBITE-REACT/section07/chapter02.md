# 02 useEffect 사용하기
## useEffect
- 리엑트 컴포넌트의 **사이드 이펙트**를 제어하는 새로운 React Hook
- 사이드 이펙트(Side Effect)
    - 우리말로 **"부작용"** 이라는 뜻
    - 리액트에서는 **"부수적인 효과"**, **"파생되는 효과"** 정도로 해석 가능
    - 예
        - "과식을 하면 살이 찐다"
        - **"살이 찐다"** 의 경우 과식을 함으로써 파생되는 효과 = **사이드 이펙트(Side Effect)**
    - 리액트 컴포넌트의 사이드 이펙트
        - 컴포넌트의 동작에 따라 파생되는 여러 효과

        |동작|사이드 이펙트|
        |:-:|:--------:|
        |컴포넌트 내부의 값 변경| 콘솔에 변경된 값 출력|
        |컴포넌트 마운트|콘솔에 "Mount"라고 출력|
        |컴포넌트 업데이트(리렌더)|콘솔에 "Update"라고 출력|
        |컴포넌트 언마운드|콘솔에 "UnMount"라고 출력|
## 실습
### 사전 준비
- 해당 섹션에서는 06섹션에서 사용했던 react 프로젝트를 그대로 사용할 것
    - 섹션 별로 정리를 하고 싶다면 node_modules 폴더만 제외하고 복사해오기.
    - `npm i`로 설치하기
    - `npm run dev`로 서버 켜기
### App.jsx에서 useEffect 사용하기
- useEffect도 react에 있는 내장 함수이기 때문에 동일 경로로 useState와 함께 불러오기
    - `import { useState, useEffect } from 'react'`
- useEffect()의 첫 번째 인수로는 콜백 함수를 넣어주고, 두 번째 인수로는 배열을 넣어준다.
    - 두 번째 인수에 들어간 배열이 바뀌게 되면 첫 번째 인수로 들어간 콜백함수를 호출하게 됨.
    - `useEffect(() => {}, [])`
    ```jsx
    useEffect(() => {
        console.log(`count: ${count}`)
    }, [count]);
    ```
    - useEffect Hook은 두 번째 인수에 의존한다.
    - 인수에 어떤 값이 들어갔느냐에 따라 다르게 동작하기 때문에 두 번째 인수인 배열을 **의존성 배열(dependency array, deps)** 이라고 부름.
    - deps에는 값을 여러개 넣어도 됨.
        - 여러 개 중 하나의 값만 바뀌어도 실행 됨.
### 이벤트 핸들러에 console을 추가하는 것과 무엇이 다를까?
```jsx
  const onClickButton = (value) => {
    setCount(count + value);
    console.log(count);
  }
```
- 이렇게 코드를 작성하고 +100 버튼을 클릭한다면 콘솔로그는 다음과 같이 뜰 것
    ```
    0
    ```
- 그리고 추가로 +1 버튼을 클릭한다면 다음과 같은 콘솔로그를 볼 수 있음
    ```
    100
    ```
- 이처럼 변경되기 이전의 값을 자꾸 콘솔에 출력하는 것.
#### 이유
- 함수 안에 setCount라는 함수는 **비동기**로 동작하기 때문
- 비동기로 동작한다.
    - setCount()를 여기에서 호출했지만 함수의 완료는 나중에 뒤늦게 되는 것을 말함.
- 즉, console.log가 호출되는 시점에는 setCount 함수가 호출만 된 것이지 완료가 된 것이 아니다. (아직 state의 값이 변경되지 않았다.)
#### 결론
- 변경된 state의 값을 바로 사용하여 side Effect에 해당하는 부가적인 작업을 진행하여야 한다면 useEffect를 사용해야 한다.
