# 02 React 컴포넌트
## 컴포넌트
- 함수가 html 코드를 반환하도록 설정할 수 있는데, 이 경우를 컴포넌트라고 함.
- 함수의 이름을 따서 App(함수의 이름) 컴포넌트라고 부름
## 컴포넌트 만들기
- App 컴포넌트 위에 함수를 선언하고 Header 컴포넌트 만들어주기 
```js
function Header() {
  return (
    <header>
      <h1>header</h1>
    </header>
  )
}
```
- 함수로 만든 컴포넌트를 리액트에서는 함수 컴포넌트라고 부르기도 함.
- 함수 선언식 말고도 화살표 함수로 바꿔서 사용할 수도 있음
```jsx
const Header = () => {
  return (
    <header>
      <h1>header</h1>
    </header>
  )
}
```
- 둘 다 동일한 경우이기에 편한 방법으로 사용하면 됨
- 함수 말고도 class를 이용하여 컴포넌트를 만들 수도 있는데, 이 경우 작성해야 할 코드가 상당히 많아지기 때문에 함수를 이용하는 방법이 편리

### 컴포넌트 주의사항
- 컴포넌트 이름의 첫 글자는 대문자로 작성해야 함. ⭐️
    - 첫 글자를 소문자로 작성할 경우 리액트에서 내부적으로 해당 함수를 컴포넌트로 인정해주지 않음
## 컴포넌트 랜더링
- 현재 상태로는 컴포넌트가 화면에 나타나지 않음
- main.jsx에서 살펴보면 App 컴포넌트는 rander 안에 넣어져 있는데 Header의 경우 그 안에 들어가 있지 않음
### App 컴포넌트 안에 Header 컴포넌트를 넣어준다.
- App 컴포넌트의 리턴문 안에 Header 컴포넌트를 작성하면 App 컴포넌트가 main에서 랜더링 될 때 함께 랜더링 됨
```jsx
function App() {

  return (
    <>
      <Header />
      <h1>안녕 리액트!</h1>
    </>
  )
}
```
- 이 경우 Header 컴포넌트처럼 다른 컴포넌트의 리턴문 내부에 포함되는 컴포넌트를 **자식 컴포넌트**라고 하고 App 컴포넌트처럼 자식 컴포넌트를 갖는 컴포넌트를 **부모 컴포넌트**라고 부름.
- 이처럼 부모-자식 구조를 갖기 때문에 계층 구조가 생김.
- 추가적으로 Main, Footer 컴포넌트를 만든다고 할 때, Header와 마찬가지로 App 컴포넌트의 자식 컴포넌트로 배치를 시켜줘야 함.
- 리액트의 모든 컴포넌트는 화면에 랜더링 되기 위해서는 App 컴포넌트의 자식 컴포넌트로 작성되어야 함.
    - 때문에 리액트의 모든 컴포넌트는 App 컴포넌트를 **최상위 조상**으로 갖는다. 
- App 컴포넌트
    - 모든 컴포넌트의 최상위 조상.
    - 뿌리 역할을 한다고 하여 **Root** 컴포넌트라고 부름
    - 루트 컴포넌트는 main.jsx에 rander에 인수로서 전달된다.
- 루트 컴포넌트는 다른 컴포넌트로 변경할 수 있음
    - 그러나 관례상 개발자들은 App이라는 이름을 가진 컴포넌트를 루트로 사용함.
## 모듈화
- 컴포넌트 별로 모듈화를 위해 각각의 파일에 작성하는 것이 일반적.
- src 폴더 안에 루트 컴포넌트를 제외한 컴포넌트들을 모아놓기 위한 "components"폴더를 제작
- 해당 폴더 안에 `Header.jsx` 파일을 작성.
- Header 컴포넌트를 해당 파일 안에 작성해준다. 
    - App 컴포넌트에 작성되어 있던 Header 컴포넌트 복사 + 붙여넣기
- Header 파일에서 컴포넌트를 내보낼 수 있게 하단에 명령어를 작성해준다.
    - `export default Header;`
- App 파일에서 Header 컴포넌트 불러오기
    - `import Header from "./components/Header";`
        - ES 모듈 시스템으로 해당 컴포넌트를 불러옴에도 불구하고 Header의 확장자명을 생략해도 됨.
        - vite로 만든 리액트 앱에서는 확장자를 작성하지 않아도 자동으로 파일을 찾아가도록 내부적으로 자동 설정 되어 있기 때문.